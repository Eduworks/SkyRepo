schema=#httpGet(obj="@typeUrl").toObject().cache(name=#add(z="@typeUrl",a="httpGet"));
schemaContext=schema.cgetByParam(param=#add(a="@",b="context"));

type=#add(a="@",b="type");
context=#add(a="@",b="context");

obj=#toObject(obj="@obj");

urlType=#add(
	_string="true",
	a=obj.getByParam(param=context).string(op="trim",chars="/"),
	b=#if(operator=obj.getByParam(param=context),operand="",ne="/"),
	c=obj.getByParam(param=type).replace(replace=obj.getByParam(param=context),with="").string(op="trim",chars="/")
);

mapUrl=#add(
	a=#urlBase(),
	b="/data/",
	c="@type",
	d="/_mapping"
);

map=mapUrl.httpGet().toObject();

properties=map.cget(data="").cget(mappings="").getByParam(param="@type").cget(properties="");

settingsUrl = #add(
	a=#urlBase(),
	b="/_settings",
);

settings = settingsUrl.httpGet().toObject(); 

noSearchList=#object(
	a="base64:base64"
).valueSet();

//Iterate over each field about to go into the document.
//	If the mapping has the field already, skip.
//	If the prefix.@type == null, skip.
//	If the schema of the @type of the field (at the appropriate nesting level) is base64:base64, add a mapping to not index the field.
// ---------------------

prefix=#split(obj="@field",split=".").remove(index=#split(obj="@field",split=".").count().add(z="-1")).flatten(_delimiter=".");
simpleType=#split(obj="@field",split=".").cgetIndex(index=#split(obj="@field",split=".").count().add(z="-1"));

prefixType=#if(
	operator=prefix,
	operand="",
	eq=urlType,
	ne=#add(
		_string="true",
		a=obj.getByParam(param=prefix.add(z=".@schema")).string(op="trim",chars="/"),
		b=#if(operator=obj.getByParam(param=prefix.add(z=".@schema")),operand="",ne="/"),
		c=obj.getByParam(param=prefix.add(z=".@type")).string(op="trim",chars="/")
	)
);

addMappingNoSearch=#object(
	properties=#object(
	).put(
		_key="@field",
		_value=#object(
			type="string",
			index="no"
		)
	)
).httpPost(url=mapUrl,multipart="false");

addWhiteSpaceRemovalMapping = #object(
	properties=#object(
	).put(
		_key="@field",
		_value=#object(
			type="string",
			analyzer="whitespace_remove"
		)
	)
).httpPost(url=mapUrl,multipart="false");

addNotAnalyzedMultiField = #object(
	properties=#object(
	).put(
		_key="@field",
		_value=#object(
			type="multi_field",
			fields=#object(
			).put(
				_key="(full)",
				_value=#object(
					type="string",
					index="not_analyzed"
				)
			).put(
				_key="@field",
				_value=#object(
					type="string",
					index="analyzed"
				)
			)
		)
	)
).httpPost(url=mapUrl, multipart="false");
			

iterateOverFields=obj.cforEach(
	paramName="field",
	valueName="value",
	op=#if(
		operator=properties.cgetByParam(param="@field"),
		operand="",
		eq=#if(
			operator=#indexOf(str="@field", substr=#add(a="@", b="owner")),
			operand="-1",
			eq=#if(
				operator=#indexOf(str="@field", substr=#add(a="@", b="type")),
				operand="-1",
				eq=#if(
					operator=prefixType,
					operand="",
					ne=#if(
						operator=noSearchList.has(has=schemaContext.call(typeUrl=prefixType.reduce()).cgetByParam(param=simpleType).cgetByParam(param=type)),
						operand="true",
						eq=addMappingNoSearch,
						ne=#debug(prefix="Not Mapping due to non-base64: ",obj="@field")
					),
					eq=#debug(prefix="Not Mapping due to lack of prefix: ",obj="@field")
				),
				ne=addNotAnalyzedMultiField,
			),
			ne=addWhiteSpaceRemovalMapping
		),
		ne="//TODO: Add multifield if field value is object but default mapping is not object (add as .obj field)"
	)
);

// Caches whether the type is protected (should be searchable/viewable by non-owners/readers)
// ---------------------
cacheDir = #string(str="./cache");
cacheName = #string(str="skyRepoCache");
cacheIndex = #string(str="skyRepoCache");
cacheKey = #string(str="encryptedTypes");

cacheDb = {
	indexDir = cacheDir,
	databaseName = cacheName,
	index= cacheIndex,
	key=cacheKey
};

cachedProtectedTypes = #idxGet(multi="true", cacheDb);

getProtectedTypes = #object(
	a=#skyRepoPredefinedEncrypted(),
	b=getProtectedTypes,
).valueSet().union();

#skyRepoGetProtectedTypes = getProtectedTypes;

addProtectedType = #if(
	operator="@cacheVal",
	operand="",
	eq=#add(a="[",b="]").toArray(),
	ne=#toArray(obj="@cacheVal")
).ccall(
	cacheVal=#cache(name=cacheKey, global="true")
).append(
	a="@typeUrl"
).idxAdd(
	cacheDb
);

types=obj.getByParam(param=type).toArray().cforEach(
	paramName="type",
	array="true",
	threaded="false",
	op=#if(
		operator=#has(obj="@type",has="http"),
		operand=true,
		eq=urlType,
		ne="@type"
	)
);

cacheSchemaProtect=#if(
	operator=getProtectedTypes.intersect(b=types).count(),
	operand="0",
	gt="true",
	eq=#if(
		operator=#httpGet(obj="@typeUrl").fileToString().toObject().getByParam(param=protect),
		operand="true",
		eq=#object(
			a=addProtectedType,
			b="true"
		).cget(b=""),
		ne="false"
	).ccall(
		typeUrl=types.getIndex(index="0")
	)
);


// Adds the whitespace_remove analyzer that removes whitespace from a field
// ---------------------

addAnalyzer = #object(
	settings=#object(
		analysis=#object(
			filter=#object(
				space_remove=#object(
					type="pattern_replace",
					pattern="\s",
					replacement=""
				)
			),
			analyzer=#object(
				whitespace_remove=#object(
					type="custom",
					tokenizer="keyword",
					filter=#add(a="[",b="]").toArray().append(a="space_remove")
				)
			)
		)
	)
).httpPut(
	url=#add(
		a=#urlBase(),
		b="/data",
	)
);

checkAddAnalyzer = #if(
	operator=#decode(obj="@settings").has(has="data"),
	operand="true",
	eq=#if(
		operator=#decode(obj="@settings").cget(data="").cget(index="").cget(analysis="").cget(analyzer="").has(has="whitespace_remove"),
		operand="true",
		ne=addAnalyzer
	),
	ne=addAnalyzer
	
).ccall(
	settings=settings
);

#addWhitespaceAnalyzer = checkAddAnalyzer;

checkType = #object(
	a=checkAddAnalyzer,
	b=cacheSchemaProtect,
	c=iterateOverFields
);

#skyRepoCheckType=checkType;